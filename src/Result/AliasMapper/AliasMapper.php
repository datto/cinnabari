<?php

/**
 * Copyright (C) 2017 Datto, Inc.
 *
 * This file is part of Cinnabari.
 *
 * Cinnabari is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * Cinnabari is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Cinnabari. If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Mark Greeley mgreeley@datto.com>
 * @license http://www.gnu.org/licenses/lgpl-3.0.html LGPL-3.0
 * @copyright 2017 Datto, Inc.
 */

namespace Datto\Cinnabari\Result\AliasMapper;

use Datto\Cinnabari\Result\SIL\SIL;
use Datto\Cinnabari\Result\SIL\Statements\DeleteStatement;
use Datto\Cinnabari\Result\SIL\Statements\SelectStatement;
use Datto\Cinnabari\Result\SIL\Tables\SelectTable;

/**
 * Class Aliases
 *
 * The final database code may need to contain aliases for tables, columns, and/or
 * parameters (e.g., the `0` in "FROM TABLE abc AS `0`"). The values of these
 * aliases can only be calculated after SQL generation is essentially complete.
 * Therefore, the database (e.g., MySQL) code generated by the Formatter contains
 * placeholders (called tags) for aliases.
 * After the Formatter has run, the final alias for each tag can be calculated by
 * AliasMapper::calculate(). AliasMapper::replaceTagsWithAliases() should then be
 * run to replace the tags in the database code with their corresponding aliases.
 *
 * @package Datto\Cinnabari\Result\AliasMapper
 */

class AliasMapper
{
    /** @var SIL */
    private $sil;

    /** @var callable */
    private $mungeFunction;

    /** @var array */
    private $aliases;

    /**
     * AliasMapper constructor.
     *
     * $mungeFunction allows the caller to perform
     * target-language-specific editing on alias names. For example,
     * MySQL aliases might need to be surrounded by backticks (e.g., `:5`).
     *
     * @param SIL $sil
     * @param callable $mungeFunction
     */
    public function __construct($sil, $mungeFunction)
    {
        $this->sil = $sil;
        $this->mungeFunction = $mungeFunction;
        $this->aliases = array();
    }

    /**
     * @param string $tag
     * @param string $alias
     */
    public function addAlias($tag, $alias)
    {
        $this->aliases[$tag] = $alias;
    }

    /**
     * @param string $tag
     *
     * @return string|null
     */
    public function getAlias($tag)
    {
        return (isset($this->aliases[$tag])) ? ($this->aliases[$tag]) : null;
    }

    /**
     * Assign an alias string for each table, column, and parameter used in the query.
     */
    public function calculate()
    {
        $parameters = $this->sil->getParameters();
        $statements = $this->sil->getStatements();
        $parameterCounter = 0;
        $tableCounter = 0;   // For FROMs, JOINs, ...
        $columnCounter = 0;
        $munge = $this->mungeFunction;

        // Calculate aliases for parameters
        foreach ($parameters as $parameter) {
            $this->addAlias($parameter->getTag(),
                $munge(':' . $parameterCounter));
            $parameterCounter++;
        }

        foreach ($statements as $statement) {

            if ($statement instanceof SelectStatement) {
                // Calculate alias for FROM table
                if ($statement->getTable() !== null) {
                    if ($statement->getTable() instanceof SelectTable) {
                        /** @var SelectTable $subquery */
                        $subquery = $statement->getTable();
                        $this->calculateSubquery($subquery, $tableCounter,
                            $columnCounter);
                    }
                    $this->addAlias($statement->getTable()->getTag(),
                        $munge($tableCounter));
                    $tableCounter++;
                }

                // Calculate aliases for SELECT columns
                foreach ($statement->getColumns() as $column) {
                    $this->addAlias($column->getTag(), $munge($columnCounter));
                    $columnCounter++;
                }

                // Calculate aliases for JOINs
                foreach ($statement->getJoins() as $join) {
                    $this->addAlias($join->getTag(), $munge($tableCounter));
                    $tableCounter++;
                }

            } elseif ($statement instanceof DeleteStatement) {
                continue;
            }
        }
    }

    private function calculateSubquery(
        SelectTable $table,
        &$tableCounter,
        &$columnCounter
    ) {
        $munge = $this->mungeFunction;

        // Calculate alias for FROM table
        if ($table->getTable() !== null) {
            if ($table->getTable() instanceof SelectTable) {
                /** @var SelectTable $subquery */
                $subquery = $table->getTable();
                $this->calculateSubquery($subquery, $tableCounter,
                    $columnCounter);
            }
            $this->addAlias($table->getTable()->getTag(),
                $munge($tableCounter));
            $tableCounter++;
        }

        // Calculate aliases for SELECT columns
        foreach ($table->getColumns() as $column) {
            $this->addAlias($column->getTag(), $munge($columnCounter));
            $columnCounter++;
        }

        // Calculate aliases for JOINs
        foreach ($table->getJoins() as $join) {
            $this->addAlias($join->getTag(), $munge($tableCounter));
            $tableCounter++;
        }

    }

    /**
     * Return a copy of the $input string, with the tags replaced by their
     * corresponding aliases.
     *
     * @param string $input
     *
     * @return string
     */
    public function replaceTagsWithAliases($input)
    {
        $output = $input;

        foreach ($this->aliases as $tag => $alias) {
            $output = str_replace($tag, $alias, $output);
        }

        return $output;
    }

    /**
     * Create a new parameter tag, and increment the parameter tag counter.
     *
     * @param int $counter
     *
     * @return string
     */
    public static function createParameterTag(&$counter)
    {
        $tag = '{{p' . $counter . '}}';
        $counter++;
        return $tag;
    }

    /**
     * Create a new table tag, and increment the table tag counter.
     *
     * @param int $counter
     *
     * @return string
     */
    public static function createTableTag(&$counter)
    {
        $tag = '{{t' . $counter . '}}';
        $counter++;
        return $tag;
    }

    /**
     * Create a new column tag, and increment the column tag counter.
     *
     * @param int $counter
     *
     * @return string
     */
    public static function createColumnTag(&$counter)
    {
        $tag = '{{c' . $counter . '}}';
        $counter++;
        return $tag;
    }
}
